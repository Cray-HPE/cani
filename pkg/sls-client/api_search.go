/*
 * System Layout Service
 *
 * System Layout Service (SLS) holds information on the complete, designed system. SLS gets this information from an input file on the system. Besides information like what hardware should be present in a system, SLS also stores information about what network connections exist and what power connections exist. SLS details the physical locations of network hardware, compute nodes and cabinets. Further, it stores information about the network, such as which port on which switch should be connected to each compute node. The API allows updating this information as well.   Note that SLS is not responsible for verifying that the system is set up correctly. It only lets the Shasta system know what the system should be configured with. SLS does not store the details of the actual hardware like hardware identifiers. Instead it stores a generalized abstraction of the system that other services may use. SLS thus does not need to change as hardware within the system is replaced. Interaction with SLS is required if the system setup changes – for example, if system cabling is altered or during  installation, expansion, or reduction. SLS does not interact with the hardware.  Each object in SLS has the following basic properties: * Parent – Each object in SLS has a parent object except the system root (s0). * Children – Objects may have children. * xname – Every object has an xname – a unique identifier for that object. * Type – a hardware type like \"comptype_ncard\", \"comptype_cabinet\". * Class – kind of hardware like \"River\" or \"Mountain\" * TypeString – a human readable type like \"Cabinet\"  Some objects may have additional properties depending on their type. For example, additional properties for cabinets include \"Network\", \"IP6Prefix\", \"IP4Base\", \"MACprefix\" etc.   ## Resources  ### /hardware  Create hardware entries in SLS. This resource can be used when you add new components or expand your system. Interaction with this resource is not required if a component is removed or replaced.  ### /hardware/{xname}  Retrieve, update, or delete information about specific xnames.   ### /search/hardware  Uses HTTP query parameters to find hardware entries with matching properties. Returns a JSON list of xnames. If multiple query parameters are passed, any returned hardware must match all parameters.  For example, a query string of \"?parent=x0\" would return a list of all children of cabinet x0. A query string of \"?type=comptype_node\" would return a list of all compute nodes.  Valid query parameters are: xname, parent, class, type, power_connector, node_nics, networks, peers.   ### /search/networks  Uses HTTP query parameters to find network entries with matching properties.  ### /networks  Create new network objects or retrieve networks available in the system.  ### /networks/{network}  Retrieve, update, or delete information about specific networks.  ### /dumpstate  Dumps the current database state of the service. This may be useful when you are backing up the system or planning a reinstall of the system.  ### /loadstate  Upload and overwrite the current database with the contents of the posted data. The posted data should be a state dump from /dumpstate. This may be useful to restore the SLS database after you have reinstalled the system.   ## Workflows  ### Backup and Restore the SLS Database for Reinstallation  #### GET /dumpstate  Perform a dump of the current state of the SLS data. This should be done before reinstalling the system. The database dump is a JSON blob in an SLS-specific format.  #### POST /loadstate  Reimport the dump from /dumpstate and restore the SLS database after reinstall.      ### Expand System  #### POST /hardware  Add the new hardware objects.  #### GET /hardware/{xname}  Review hardware properties of the xname from the JSON array.  ### Remove Hardware  #### DELETE /hardware  Remove hardware from SLS  ### Modify Hardware Properties  #### PATCH /hardware  Modify hardware properties in SLS. Only additional properties can be modified. Basic properties like xname, parent, children, type, class, typestring cannot be modified.
 *
 * API version: 0.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package sls_client

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type SearchApiService service

/*
SearchApiService Search for nodes matching a set of criteria
Search for nodes matching a set of criteria. Any of the properties of any entry in the database may be used as search keys.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SearchApiSearchHardwareGetOpts - Optional Parameters:
     * @param "Xname" (optional.Interface of string) -  Matches the specified xname
     * @param "Parent" (optional.Interface of string) -  Matches all objects that are direct children of the given xname
     * @param "Class" (optional.Interface of HardwareClass) -  Matches all objects of the given class
     * @param "Type_" (optional.Interface of HardwareType) -  Matches all objects of the given type
     * @param "PowerConnector" (optional.Interface of string) -  Matches all objects with the given xname in their power_connector property
     * @param "Object" (optional.Interface of string) -  Matches all objects with the given xname in their object property.
     * @param "NodeNics" (optional.Interface of string) -  Matches all objects with the given xname in their node_nics property
     * @param "Networks" (optional.String) -  Matches all objects with the given xname in their networks property
     * @param "Peers" (optional.Interface of string) -  Matches all objects with the given xname in their peers property
@return []Hardware
*/

type SearchApiSearchHardwareGetOpts struct {
	Xname          optional.Interface
	Parent         optional.Interface
	Class          optional.Interface
	Type_          optional.Interface
	PowerConnector optional.Interface
	Object         optional.Interface
	NodeNics       optional.Interface
	Networks       optional.String
	Peers          optional.Interface
}

func (a *SearchApiService) SearchHardwareGet(ctx context.Context, localVarOptionals *SearchApiSearchHardwareGetOpts) ([]Hardware, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []Hardware
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/search/hardware"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Xname.IsSet() {
		localVarQueryParams.Add("xname", parameterToString(localVarOptionals.Xname.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Parent.IsSet() {
		localVarQueryParams.Add("parent", parameterToString(localVarOptionals.Parent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Class.IsSet() {
		localVarQueryParams.Add("class", parameterToString(localVarOptionals.Class.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PowerConnector.IsSet() {
		localVarQueryParams.Add("power_connector", parameterToString(localVarOptionals.PowerConnector.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Object.IsSet() {
		localVarQueryParams.Add("object", parameterToString(localVarOptionals.Object.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeNics.IsSet() {
		localVarQueryParams.Add("node_nics", parameterToString(localVarOptionals.NodeNics.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Networks.IsSet() {
		localVarQueryParams.Add("networks", parameterToString(localVarOptionals.Networks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Peers.IsSet() {
		localVarQueryParams.Add("peers", parameterToString(localVarOptionals.Peers.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Hardware
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SearchApiService Perform a search for networks matching a set of criteria.
Perform a search for networks matching a set of criteria.  Any of the properties of any entry in the database may be used as search keys.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SearchApiSearchNetworksGetOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Matches the specified network name
     * @param "FullName" (optional.String) -  Matches the specified network full name
     * @param "Type_" (optional.Interface of string) -  Matches the specified network type
     * @param "IpAddress" (optional.Interface of string) -  Matches all networks that could contain the specified IP address in their IP ranges
@return []Network
*/

type SearchApiSearchNetworksGetOpts struct {
	Name      optional.String
	FullName  optional.String
	Type_     optional.Interface
	IpAddress optional.Interface
}

func (a *SearchApiService) SearchNetworksGet(ctx context.Context, localVarOptionals *SearchApiSearchNetworksGetOpts) ([]Network, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []Network
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/search/networks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FullName.IsSet() {
		localVarQueryParams.Add("full_name", parameterToString(localVarOptionals.FullName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpAddress.IsSet() {
		localVarQueryParams.Add("ip_address", parameterToString(localVarOptionals.IpAddress.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []Network
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
