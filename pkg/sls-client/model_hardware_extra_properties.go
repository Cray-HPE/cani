// This is custom code that is not generated by swagger-codegen
// The SLS Hardware extra proeprteis is context dependent with different structs allowed.
// The code generate does struct compoistion, and things are not well behaved when performing
// JSON unmarshalling if multiple of these structs have the same field which causes these fields
// to be ignored.
package sls_client

import (
	"fmt"

	"github.com/Cray-HPE/hms-xname/xnametypes"
	"github.com/mitchellh/mapstructure"
)

type HardwareExtraProperties map[string]interface{}

func (hardware *Hardware) DecodeExtraProperties() (result interface{}, err error) {
	// This can be filled out with types with some help of the following. Doesn't fully work, but gets you close
	// $ cat pkg/sls-common/types.go | grep '^type Comptype' | sort
	switch xnametypes.GetHMSType(hardware.Xname) {
	case xnametypes.NodeBMCNic:
		result = HardwareExtraPropertiesBmcNic{}
	case xnametypes.CDUMgmtSwitch:
		result = HardwareExtraPropertiesCduMgmtSwitch{}
	case xnametypes.CabinetPDUNic:
		result = HardwareExtraPropertiesCabPduNic{}
	case xnametypes.Cabinet:
		result = HardwareExtraPropertiesCabinet{}
	case xnametypes.ChassisBMC:
		result = sls_common.ComptypeChassisBmc{}
	case xnametypes.ComputeModule:
		result = sls_common.ComptypeCompmod{}
	case xnametypes.NodePowerConnector:
		result = sls_common.ComptypeCompmodPowerConnector{}
	case xnametypes.NodeHsnNic:
		result = sls_common.ComptypeNodeHsnNic{}
	case xnametypes.HSNConnectorPort:
		result = sls_common.ComptypeHSNConnector{}
	case xnametypes.MgmtHLSwitch:
		result = sls_common.ComptypeMgmtHLSwitch{}
	case xnametypes.MgmtSwitch:
		result = sls_common.ComptypeMgmtSwitch{}
	case xnametypes.MgmtSwitchConnector:
		result = sls_common.ComptypeMgmtSwitchConnector{}
	case xnametypes.Node:
		result = sls_common.ComptypeNode{}
	case xnametypes.NodeBMC:
		result = sls_common.ComptypeNodeBmc{}
	case xnametypes.NodeNic:
		result = sls_common.ComptypeNodeNic{}
	case xnametypes.RouterBMC:
		result = sls_common.ComptypeRtrBmc{}
	case xnametypes.RouterBMCNic:
		result = sls_common.ComptypeRtrBmcNic{}
	case xnametypes.RouterModule:
		result = sls_common.ComptypeRtrBmcNic{}
	default:
		// Not all SLS types have an associated struct. If EP is nil, then its not a problem.
		if hardware.ExtraPropertiesRaw == nil {
			return nil, nil
		}

		return nil, fmt.Errorf("hardware object (%s) has unexpected properties", hardware.Xname)
	}

	// Decode the Raw extra properties into a give structure
	decoder, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{
		DecodeHook: mapstructure.StringToIPHookFunc(),
		Result:     &result,
	})
	if err != nil {
		return nil, err
	}
	err = decoder.Decode(hardware.ExtraPropertiesRaw)

	return result, err
}
